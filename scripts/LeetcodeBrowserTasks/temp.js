async function getProblemDetails(titleSlug) {  const BASE_URL = "https://leetcode.com/graphql/";  console.info("Fetching problem details...");  const query = queryGenerator(titleSlug);  try {  const response = await fetch(BASE_URL, {method: "POST",headers: { "Content-Type": "application/json",},body: JSON.stringify({ query }),});  if (!response.ok) {console.error("Failed to retrieve page");throw new Error("Failed to retrieve question details");}const data = await response.json();  if (!data || !data.data || !data.data.question) {console.error("Invalid URL");throw new Error("Invalid URL");}  console.info("Data fetched successfully");const problem = data.data.question;  return {questionId: problem.questionId,questionFrontendId: problem.questionFrontendId,questionTitle: problem.title,question: problem.content,link: `https://leetcode.com/problems/${problem.titleSlug}`,difficulty: problem.difficulty,topicTags: problem.topicTags,titleSlug: problem.titleSlug,};  } catch (error) {  console.error(error.message);throw new Error(error.message);  }}function queryGenerator(titleSlug) {titleSlug = titleSlug.replace(/ /g, "-").replace(/\//g, ""); const query = `  query { question(titleSlug: "${titleSlug}") { questionId questionFrontendId title titleSlug content difficulty topicTags { name slug translatedName } }  }`; console.info("Query generated");return query;}
function getExtension(language) {const extensionMap = {python3: "py",python: "py",pandas: "py",java: "java",c: "c",cpp: "cpp",csharp: "cs",javascript: "js",typescript: "ts",ruby: "rb",swift: "swift",go: "go",kotlin: "kt",scala: "scala",rust: "rs",php: "php",mysql: "sql",bash: "sh",perl: "pl",haskell: "hs",dart: "dart",racket: "rkt",elixir: "ex",erlang: "erl","objective-c": "m",matlab: "m",fsharp: "fs",lua: "lua",groovy: "groovy","vb.net": "vb",fortran: "f90",pascal: "pas",julia: "jl",prolog: "pl",scheme: "scm",cobol: "cbl",solidity: "sol",};return extensionMap[language.toLowerCase()] || "txt";}async function organizeLeetcodeSolutions(rawSolutions) {console.info("Organizing Leetcode solutions...");const submissionsDump = rawSolutions.submissions_dump;const uniqueRecentSubmissions = {};const uploads = [];const tasks = [];const taskMapping = {};for (const submission of submissionsDump) {if (submission.status_display !== "Accepted") continue;const { timestamp, title_slug, lang_name, code } = submission;const codeExtension = getExtension(lang_name);const solution = { code, codeExtension };if (!uniqueRecentSubmissions[title_slug]) {    const task = getProblemDetails(title_slug);    tasks.push(task);taskMapping[title_slug] = tasks.length - 1;    uploads.push({ question: null, solution });    uniqueRecentSubmissions[title_slug] = {    timestamp,    index: uploads.length - 1,    };}if (uniqueRecentSubmissions[title_slug]?.timestamp < timestamp) {    uniqueRecentSubmissions[title_slug].timestamp = timestamp;    uploads[uniqueRecentSubmissions[title_slug].index] = {    question: null,    solution,    };}}const problemDetailsList = await Promise.all(tasks);for (const [titleSlug, taskIndex] of Object.entries(taskMapping)) {const problemDetails = problemDetailsList[taskIndex];const index = uniqueRecentSubmissions[titleSlug].index;uploads[index].question = problemDetails;}return { uploads };}
function sleep(ms) {return new Promise((resolve) => setTimeout(resolve, ms));}async function fetchSubmissions() {let offset = 0;let hasNext = true;let submissions = { submissions_dump: [] };while (hasNext) {  try {const response = await fetch(  `https://leetcode.com/api/submissions/?offset=${offset}`  );if (!response.ok) {  throw new Error("HTTP error! status: ${response.status}");  }const data = await response.json();submissions.submissions_dump.push(...(data.submissions_dump || []));console.log("Offset is", offset);offset += 20;  hasNext = data.has_next;  await sleep(500);   } catch (error) {console.error("Error:", error);break;   }}console.log("Fetching submission from leetcode completed!");const result = await organizeLeetcodeSolutions(submissions);console.log(result);}fetchSubmissions();